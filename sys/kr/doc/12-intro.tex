\Introduction
При разработке или анализе програм часто бывает полезно иметь возможность 
узнавать, какие системные вызовы делает программа. Для этих целей 
существует утилита strace. 
Однако эту утилиту тяжело применять отладки целых систем включающих 
взаимодйствие нескольких процессов также, как и для отладки демонов, 
запускаемых скриптами инициализации.
\begin{lstlisting}[caption={Пример вывода strace Hellow World'а (вызовы, 
		связанные с динамической линковкой опущены)}]
$ strace ./hw >/dev/null
execve("./hw", ["./hw"], [/* 64 vars */]) = 0
brk(0)                                  = 0x2596000
...
fstat(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
ioctl(1, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0x7fff0c8efe30) = -1 ENOTTY (Inappropriate ioctl for device)
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f96fbce5000
write(1, "Hellow World!\n", 14)         = 14
exit_group(0)                           = ?$ 
\end{lstlisting}

%!!! here



% Зачастую бывает необходимо отследить за работой того или иного процесса с памятью, например, чтобы обнаружить утечки памяти, узнать, в какие моменты и сколько памяти процесс выделяет. Для решения данной задачи существует ряд средств, а именно:
% Файловая система /proc - позволяет прочесть различную информацию о всей системе в целом и о каждом из процессов, в том числе информацию об использовании процессом памяти и об отображениях памяти данного процесса. (пример:
% # cat /proc/`pgrep test`/status
% 		Name:   test1
% 		...
% 		VmPeak:     1556 kB
% 		VmSize:     1544 kB
% 		VmLck:         0 kB
% 		VmHWM:       308 kB
% 		VmRSS:       308 kB
% 		VmData:      148 kB
% 		VmStk:        88 kB
% 		VmExe:         4 kB
% 		VmLib:      1276 kB
% 		VmPTE:        12 kB
% 
% # cat /proc/`pgrep test`/maps
% 		08048000-08049000 r-xp 00000000 08:01 17432879   /home/twee/work/mstu/coding/memmon/test/test1
% 		08049000-0804a000 rw-p 00000000 08:01 17432879   /home/twee/work/mstu/coding/memmon/test/test1
% 		0804a000-0806b000 rw-p 0804a000 00:00 0          [heap]
% 		b7e4b000-b7e4c000 rw-p b7e4b000 00:00 0
% 		b7e4c000-b7f75000 r-xp 00000000 03:05 1604119    /lib/tls/libc-2.3.6.so
% b7f75000-b7f76000 r--p 00128000 03:05 1604119    /lib/tls/libc-2.3.6.so
% b7f76000-b7f79000 rw-p 00129000 03:05 1604119    /lib/tls/libc-2.3.6.so
% b7f79000-b7f7c000 rw-p b7f79000 00:00 0
% b7f9d000-b7fb3000 r-xp 00000000 03:05 752968     /lib/ld-2.3.6.so
% b7fb3000-b7fb5000 rw-p 00015000 03:05 752968     /lib/ld-2.3.6.so
% bfc2a000-bfc40000 rw-p bfc2a000 00:00 0          [stack]
% ffffe000-fffff000 r-xp 00000000 00:00 0          [vdso]
% 	). На приведенной распечатке видно, сколько памяти использует процесс test и под 	какие именно нужды, а так же его карту памяти. Однако, таким образом нельзя 	отследить динамику работы процесса с памятью.
% 	strace - утилита, позволяющая трассировать все системные вызовы, выполняемые данным процессом (в частности, выделение памяти вызовами brk/mmap). Она использует стандартный отладочный механизм ядра под названием ptrace – подключается к исследуемому процессу как отладчик (вызовов ptrace(), указывая при этом флаг PTRACE_SYSCALL, что заставляет систему уведомлять трассирующий процесс о всех системных вызовах трассируемого). Пример его работы: 
% 	execve("./test3", ["test3"], [/* 61 vars */]) = 0
% 	...
% 	fsync(0)                                = -1 EINVAL (Invalid argument)
% 	mmap2(NULL, 2101248, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7bf4000
% 	fsync(1)                                = -1 EINVAL (Invalid argument)
% 	fsync(2)                                = -1 EINVAL (Invalid argument)
% 	munmap(0xb7bf4000, 2101248)             = 0
% 	exit_group(0)
% 	На приведенной трассировке видно, как процесс выделяет и освобождает 2101248 байт памяти. К сожалению, это средство не позволяет следить за всеми процессами в системе в целом, а так же за выделениями физических страниц процессу.
% 	Таким образом, возникает необходимость в средстве, позволяющем отслеживать не только выделения виртуальной памяти процессу, но и выделения отдельных страниц физической памяти в результате страничных сбоев.
% 
